
# MySQL 정렬 처리 방식 정리

MySQL(InnoDB)은 ORDER BY 또는 GROUP BY 등에서 정렬이 필요할 때 내부적으로 여러 가지 전략을 사용한다.     
정렬 방법은 크게 다음 세 가지이다.

1. 인덱스를 사용한 정렬
2. 조인에서 드라이빙 테이블만 정렬
3. 조인 결과를 임시 테이블에 저장한 후 정렬

각 방식은 비용, 메모리 사용, 정렬 가능 여부가 다르므로 실행 계획을 해석하는 과정에서 정확히 이해해야 한다.

---

## 1. 인덱스를 사용한 정렬

### 개념

ORDER BY가 인덱스의 정렬 순서와 동일하면 MySQL은 별도의 정렬 작업 없이 **인덱스 순서대로 데이터만 읽어서 정렬을 완료한다.**    
이 경우 Filesort가 발생하지 않고 비용이 가장 낮다.

### 사용 조건

* ORDER BY가 인덱스 구성과 완전히 일치해야 한다.
* WHERE 조건과 ORDER BY의 선두 컬럼이 동일해야 한다.
* 정렬 방향(ASC/DESC)이 인덱스 전체에서 일치해야 한다.

### 예시

인덱스

```
INDEX (age, name)
```

쿼리

```
SELECT * FROM user
WHERE age = 20
ORDER BY name;
```

위 쿼리는 age = 20 범위에서 name의 정렬 순서가 인덱스와 일치하므로 별도 정렬 없이 처리된다.

---

## 2. 조인에서 드라이빙 테이블만 정렬

### 개념

조인을 수행할 때, MySQL은 드라이빙 테이블(먼저 읽는 테이블)의 결과만 정렬한 후, 그 순서대로 드리븐 테이블과 조인한다.       
이 경우 모든 조인 결과를 정렬하는 것보다 비용이 낮을 수 있다.

### 특징

* 드라이빙 테이블은 ORDER BY 조건을 맞추어 정렬할 수 있다.
* 드리븐 테이블은 정렬되지 않지만, 조인 시 정렬된 순서를 유지해서 결과적으로 ORDER BY를 만족한다.
* Filesort가 수행될 수 있으나 조인 전체 결과를 정렬하는 것보다 비용이 낮다.

### 예시

```
SELECT *
FROM customer c
JOIN order o ON c.id = o.customer_id
ORDER BY c.age;
```

customer가 드라이빙 테이블이고 age로 정렬이 가능하다면,
customer를 정렬 → order와 조인 → 최종 결과는 정렬 순서를 유지한다.

---

## 3. 조인 결과를 임시 테이블로 저장한 후 정렬

### 개념

ORDER BY가 조인된 여러 테이블의 컬럼을 포함하거나 인덱스 조건과 맞지 않는 경우,
MySQL은 **조인된 전체 결과를 임시 테이블에 저장한 뒤 Filesort로 정렬한다.**

### 특징

* 가장 비용이 높은 정렬 방식이다.
* 임시 테이블이 디스크로 spill될 가능성이 있다.
* 조인 결과가 많을수록 매우 느려진다.
* ORDER BY에 조인된 여러 테이블의 컬럼이 섞여 있으면 필연적으로 발생한다.

### 예시

```
SELECT *
FROM customer c
JOIN order o ON c.id = o.customer_id
ORDER BY o.created_at, c.age;
```

ORDER BY에 두 테이블의 컬럼이 섞여 있으므로
MySQL은 반드시 전체 조인 결과를 생성하고, 임시 테이블을 만든 후 정렬해야 한다.

---

# 정렬 방식 비교 표

| 구분             | 인덱스를 사용한 정렬                 | 드라이빙 테이블만 정렬                   | 조인 결과 전체 정렬                           |
| -------------- | --------------------------- | ------------------------------ | ------------------------------------- |
| 내부 처리 방식       | 인덱스 순서대로 읽어서 정렬 수행 없이 완료    | 드라이빙 테이블만 정렬 후 조인 수행           | 조인된 전체 결과를 임시 테이블에 저장 후 Filesort      |
| Filesort 발생 여부 | 없음                          | 있음(부분적)                        | 있음(전체 결과 정렬)                          |
| 임시 테이블 사용 여부   | 없음                          | 없을 수도 있음                       | 대부분 사용                                |
| 성능             | 가장 빠름                       | 중간                             | 가장 느림                                 |
| 사용 조건          | ORDER BY가 인덱스와 완전히 일치       | ORDER BY가 드라이빙 테이블에만 적용 가능한 경우 | ORDER BY에 여러 테이블 컬럼이 존재하거나 인덱스 조건 불일치 |
| 예시             | `ORDER BY age` (age 인덱스 있음) | `ORDER BY c.age` (c가 드라이빙)     | `ORDER BY c.age, o.date`              |
