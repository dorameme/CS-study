# FROM 절 순서와 드라이빙 테이블

## 질문

`FROM A JOIN B` 와 `FROM B JOIN A` 를 각각 작성했을 때 드라이빙 테이블이 같을까? 그 이유는 무엇인가?

## 결론(요약)

 기본적으로 드라이빙 테이블은 옵티마이저가 비용(cost) 기반으로 자동 선택한다.    
 따라서 단순히 FROM 절 순서를 바꾼다고 해서 드라이빙 테이블이 항상 달라지지는 않는다.    
 대부분의 경우에는 두 쿼리에서 같은 드라이빙 테이블이 선택된다.     
 그러나 통계, 인덱스 상태, 조건의 특성 등에 따라 드물게 서로 다른 드라이빙 테이블이 선택될 수 있다.

## 상세 설명

### 옵티마이저의 역할

 MySQL 옵티마이저는 가능한 조인 순서들을 평가하여 추정 비용이 가장 낮은 순서를 선택한다.      
 옵티마이저는 `FROM` 절의 작성 순서를 무시하고 내부적으로 여러 조인 순서를 비교한다.       
 따라서 개발자가 `FROM A JOIN B` 또는 `FROM B JOIN A` 로 작성해도 옵티마이저는 두 경우를 모두 고려하여 최적의 실행 계획을 선택한다.     

### 드라이빙 테이블 선정 기준

 필터링 효율(선택도/selectivity): WHERE 조건이나 인덱스에 의해 결과가 크게 줄어드는 테이블이 유리하다.     
 테이블 크기: 작은 테이블을 먼저 읽는 것이 전체 비용을 줄이는 경우가 많다.     
 조인 키의 인덱스 유무: 드라이빙 테이블에서 읽은 행으로 상대 테이블을 인덱스로 빠르게 조회할 수 있어야 비용이 낮아진다.    
 통계의 정확성: 테이블 통계가 오래되어 부정확하면 옵티마이저의 추정이 틀려질 수 있다.    

### 언제 다를 수 있는가

 통계가 오래되어 카디널리티 추정이 부정확한 경우    
 조건이 미세하게 다르거나, 옵티마이저가 비용을 동일하게 판단하지 못하는 경우    
 `optimizer_switch` 설정이나 특정 최적화가 비활성화된 경우    
 힌트(`STRAIGHT_JOIN`, `/+ LEADING(...) /`, `/+ JOIN_ORDER(...) /`)로 강제한 경우    

## 예시

아래 예시는 실제 `EXPLAIN` 출력 값은 아니지만, 이해를 돕기 위한 단순화된 가상 예시이다.

### 예시 1 — 드라이빙 테이블이 같은 경우(일반적인 경우)

쿼리 A:

```sql
SELECT 
FROM user u
JOIN orders o ON u.id = o.user_id
WHERE u.id = 100;
```

쿼리 B:

```sql
SELECT 
FROM orders o
JOIN user u ON u.id = o.user_id
WHERE u.id = 100;
```

 설명: `user.id = 100` 조건이 매우 선택적(1행만 추출)이다.          
 옵티마이저는 두 쿼리 모두에서 `user`를 먼저 읽고 `orders`를 인덱스로 조회하는 계획을 선택한다.     
 결론: 두 쿼리 모두 동일하게 `user`가 드라이빙 테이블이다.     

### 예시 2 — 드라이빙 테이블이 달라지는 경우(통계/복잡성 영향)

상황: `user` 테이블 통계가 오래되어 실제로는 `user.id = 100`이 1000건을 반환하지만 통계는 1건으로 추정되어 있다.      
또한 `orders`는 인덱스가 잘 되어 있고 작은 테이블이다.   

 옵티마이저가 `user`가 더 효율적이라고 추정하면 `user`가 드라이빙 테이블이 된다.        
 하지만 실제 비용을 계산하면 `orders`를 먼저 읽어 `user`를 인덱스로 조회하는 쪽이 더 저렴하다.       
 결과적으로 동일한 SQL을 FROM 순서만 바꾸면 옵티마이저의 내부 추정치와 플랜 탐색 방식에 따라 서로 다른 드라이빙 테이블이 선택될 수 있다.
    
* 작은 통계 오차나 비용 계산 방식의 미세한 차이가 드라이빙 테이블을 바꿀 수 있다. *


## 실무 권장 사항

1. 통계 갱신: `ANALYZE TABLE`로 통계를 주기적으로 갱신하여 옵티마이저의 추정을 정확하게 유지한다.     
2. 힌트 사용은 신중하게: 성능 문제를 확실히 파악한 후에 `STRAIGHT_JOIN` 또는 `LEADING` 같은 힌트로 조인 순서를 강제한다.    
3. 인덱스 설계: 조인에 사용되는 컬럼에 적절한 인덱스를 두어 어느 쪽을 드라이빙으로 선택해도 효율적이게 만든다.    
4. EXPLAIN으로 검증: 쿼리 변경 후 항상 `EXPLAIN`으로 실행 계획을 확인한다.

## 최종 요약

 `FROM` 절 순서를 바꾸는 것만으로 드라이빙 테이블이 항상 바뀌지는 않는다.       
 옵티마이저가 비용 기반으로 최적의 순서를 선택하기 때문에 보통은 같은 드라이빙 테이블이 선택된다.    
 다만 통계, 인덱스, 비용 계산의 미세한 차이로 인해 서로 다른 드라이빙 테이블이 선택될 수 있다.    
 필요하면 힌트로 강제할 수 있으나, 먼저 통계와 인덱스, EXPLAIN을 점검하는 것이 우선이다.    

---

작성자: 자동 생성
작성일: 2025-11-24
