# MySQL FOR UPDATE 정리

## 1. FOR UPDATE 개념

`SELECT ... FOR UPDATE`는 조회한 레코드에 배타적 잠금(Exclusive Lock)을 건다.
이 잠금은 트랜잭션이 끝날 때까지 유지된다.
다른 트랜잭션은 동일한 레코드 또는 잠금 범위를 수정하거나 삽입할 수 없다.

---

## 2. FOR UPDATE가 일반적으로 사용되지 않는 이유

### 2.1 동시성 저하

배타적 락이 걸리면 동일한 행 또는 범위에 접근하는 다른 트랜잭션이 모두 대기하게 된다.
트래픽이 많은 환경에서는 작은 락 하나가 전체 성능을 크게 떨어뜨린다.

### 2.2 넥스트 키 락으로 인해 범위가 불필요하게 넓어진다

PK 또는 Unique Key로 한 행을 지정하면 문제가 없지만,
범위 검색이 되면 넥스트 키 락이 걸리면서
해당 조건 범위 전체의 삽입까지 차단된다.
이로 인해 병목이 쉽게 발생한다.

### 2.3 데드락 가능성이 증가한다

여러 트랜잭션이 서로 다른 자원을 잠근 뒤 서로가 가진 자원을 요구하면 데드락이 발생한다.
FOR UPDATE는 배타적 락을 사용하므로 데드락 발생 확률이 증가한다.

### 2.4 트랜잭션 유지 시간이 길어질수록 문제가 증폭된다

코드 실행 중 외부 API 호출, 비즈니스 로직 등의 시간이 포함되면
그 시간 동안 락이 유지되어 전체 시스템 지연을 유발한다.

### 2.5 인덱스를 타지 않으면 테이블 전체가 잠길 수 있다

WHERE절에 적절한 인덱스가 없으면 테이블 스캔이 발생하며
넥스트 키 락이 테이블 대부분을 잠가버릴 수 있다.

---

## 3. FOR UPDATE를 반드시 써야 하는 상황

일반적으로 피해야 하지만, 아래의 경우에는 반드시 필요하다.

### 3.1 재고 차감, 좌석 예매처럼 순서를 보장해야 하는 경우

특정 자원을 동시에 수정할 때 정확한 순서와 무결성이 필요하다면
FOR UPDATE로 레코드 단위의 동시성 제어가 필요하다.

### 3.2 같은 행에 대해 조회 후 수정해야 하는 경우

조회 결과를 바탕으로 UPDATE를 수행하는 패턴
(예: 사용자 포인트 계산)은 데이터 정합성을 위해 잠금이 필요하다.

### 3.3 트랜잭션 단위에서 여러 행을 안전하게 묶어야 하는 경우

여러 레코드를 동시에 수정해야 하며,
중간에 외부 트랜잭션이 간섭하면 안 되는 로직.

### 3.4 단일 MySQL 서버 환경에서 확실한 비관적 락이 필요한 경우

Redis나 다른 분산락 시스템을 사용할 수 없는 구조에서는
DB 레벨의 비관적 락이 유일한 제어 수단이 된다.

---

## 4. FOR UPDATE의 내부 동작 방식

### 4.1 레코드 락

PK 또는 Unique 조건으로 정확한 하나의 행만 잠근다.

### 4.2 갭 락

조건 범위 안의 빈 공간까지 잠그며 삽입을 차단한다.

### 4.3 넥스트 키 락

레코드 + 갭을 동시에 잠그는 락이며
InnoDB의 기본 잠금 방식이다.
범위 검색 시 기본적으로 넥스트 키 락이 걸린다.

---

## 5. FOR UPDATE가 성능에 영향을 주는 이유 요약

1. 불필요하게 큰 범위를 잠그는 넥스트 키 락
2. 다른 트랜잭션 대기 증가
3. 데드락 발생 확률 증가
4. 긴 트랜잭션 유지로 인한 병목
5. 인덱스 미사용 시 테이블 넓은 범위가 잠김

---

## 6. FOR UPDATE를 대체할 수 있는 방법

### 6.1 Optimistic Locking

버전 칼럼을 두어 충돌 시 재시도하는 방식
락을 거의 사용하지 않음.

### 6.2 원자적 UPDATE

조회 없이 바로 UPDATE로 해결
예시

```sql
UPDATE stock SET qty = qty - 1 WHERE id = 1 AND qty > 0;
```

### 6.3 Unique 인덱스를 활용한 삽입 제어

중복 제어를 락 없이 해결할 수 있다.

### 6.4 Redis나 ZooKeeper를 활용한 분산락

DB 락보다 성능이 뛰어나고 확장성이 좋다.

---

## 7. 실무적인 결론

1. 일반적인 SELECT에는 절대 FOR UPDATE를 사용하지 않는다.
2. 동시성 환경에서는 FOR UPDATE가 병목의 주요 원인이 된다.
3. 정확한 순서 보장이 필요한 자원 관리(재고, 좌석 등)에서는 반드시 필요하다.
4. 불필요한 범위 검색이 포함되면 넥스트 키 락으로 인해 잠금 범위가 과도하게 넓어진다.
5. 가능한 경우 Optimistic Locking 또는 원자적 UPDATE 방식으로 대체한다.

---

원하면 이 README에 **인덱스 구조에 따른 락 범위 그림**,
혹은 **실제 데드락 발생 예제(SQL)** 도 추가해줄 수 있다.
