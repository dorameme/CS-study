

# Full Index Scan vs Full Table Scan

## 1. 개념 비교 표

| 항목                   | Full Index Scan                                  | Full Table Scan                      |
| -------------------- | ------------------------------------------------ | ------------------------------------ |
| 스캔 대상                | 인덱스 전체를 선형적으로 읽는다                                | 테이블 전체 레코드를 선형적으로 읽는다                |
| 읽는 데이터 크기            | 인덱스는 보통 테이블보다 훨씬 작다                              | 테이블은 실제 데이터 페이지 전체를 포함하므로 크다         |
| 발생 조건                | 인덱스를 사용할 수 있지만 범위가 너무 넓거나, 정렬/집계를 위해 인덱스가 적합한 경우 | 인덱스를 사용할 수 없거나, 인덱스를 사용해도 효율적이지 않을 때 |
| I/O 비용               | 상대적으로 낮다                                         | 가장 높은 편이다                            |
| 대표 실행 계획 표시          | index                                            | ALL                                  |
| covering index 이용 여부 | 가능                                               | 불가능                                  |
| 일반적 속도               | 테이블 스캔보다 빠른 경우 많음                                | 가장 느린 방식                             |

---

## 2. 개념 상세 설명

### Full Index Scan

Full Index Scan은 **특정 인덱스를 처음부터 끝까지 모두 읽는 방식**이다.

* 인덱스가 테이블보다 훨씬 작기 때문에 전체를 읽어도 비용이 낮다.
* WHERE 조건이 인덱스 활용이 가능하나 범위가 넓은 경우
* ORDER BY, GROUP BY가 인덱스 정렬 순서와 일치하는 경우
* SELECT COUNT(*)처럼 **테이블의 실제 데이터 페이지를 읽을 필요가 없는 경우**

특히 InnoDB에서는 **PRIMARY KEY 인덱스 역시 B-Tree이므로 COUNT(*) 시 이를 먼저 스캔함**.

---

### Full Table Scan

Full Table Scan은 **테이블 전체 레코드를 직접 읽는 방식**이다.

* 인덱스가 없거나, 인덱스 조건 효율이 매우 낮을 때 발생
* SELECT * 처럼 **모든 컬럼을 반환해야 하는 경우** 인덱스만 보고 답을 낼 수 없기 때문에 테이블 전체 데이터 페이지를 읽는다
* 테이블 자체가 크면 I/O가 크게 증가하며 가장 비싼 방식이다

---

## 3. 예시와 함께 비교

### 3.1 SELECT COUNT(*) FROM A

이 쿼리는 보통 **풀 인덱스 스캔**을 수행한다.

#### 이유

1. COUNT(*)는 실제 데이터 값이 필요 없다

   * COUNT는 단순히 "레코드 수"만 세면 되므로 **모든 컬럼 데이터를 읽을 필요가 없다**.

2. InnoDB는 PK를 기준으로 클러스터링되어 있으므로

   * PRIMARY KEY 인덱스가 테이블 전체를 대표한다
   * 따라서 PK 인덱스(B-Tree)의 리프 노드를 선형 스캔하는 것으로 충분하다.

3. 인덱스는 테이블보다 크기가 훨씬 작기 때문에

   * 옵티마이저는 **인덱스를 읽는 것이 더 빠르다**고 판단한다.

즉, COUNT(*)는 테이블의 실제 데이터를 보지 않아도 되므로 **인덱스 전체를 스캔하는 것이 최적**이다.

#### 실행 흐름

```
PRIMARY KEY 인덱스 전체 스캔 → 레코드 개수 증가 → 결과 반환
```

---

### 3.2 SELECT * FROM a

이 쿼리는 **풀 테이블 스캔**이 발생할 가능성이 매우 높다.

#### 이유

1. 모든 컬럼을 읽어야 한다

   * 인덱스에는 보통 일부 컬럼만 포함되어 있다.
   * 따라서 인덱스만 읽어서는 충분하지 않다.

2. 인덱스를 거쳐 테이블 데이터를 다시 찾아야 하는데

   * 인덱스 → 테이블로의 랜덤 I/O가 많이 발생한다
   * 오히려 테이블 자체를 순차적으로 스캔하는 것이 더 효율적이다.

3. WHERE 조건도 없으므로 모든 데이터를 반환해야 한다

   * 이 경우 테이블 전체를 읽는 것이 가장 간단하고 비용이 예측 가능하다.

#### 실행 흐름

```
테이블 전체 데이터 페이지 선형 스캔 → 모든 레코드 반환
```

즉, SELECT *은 실제 데이터 페이지를 전부 가져와야 하므로 **Full Table Scan이 기본**이다.

---

## 4. 정리

* COUNT(*)는 "값" 자체가 아니라 "개수"만 필요하므로 테이블의 모든 컬럼을 읽을 필요가 없다.
  따라서 테이블보다 크기가 작은 **인덱스 전체를 선형 스캔하는 방식(Full Index Scan)**이 선택된다.

* SELECT *은 모든 열을 실제 값까지 읽어야 한다.
  따라서 인덱스로는 부족하고 테이블 전체 데이터를 직접 읽는 **Full Table Scan**이 선택된다.

* 결국 핵심 차이는 다음과 같다.

  * COUNT(*) = 인덱스만 있으면 충분하므로 Full Index Scan
  * SELECT * = 테이블의 실제 데이터를 읽어야 하므로 Full Table Scan

