

# MySQL 인덱스 완전 정복

## 1. 인덱스란 무엇인가

인덱스는 데이터를 빠르게 찾기 위한 **정렬된 자료구조**이다.
MySQL(InnoDB)은 기본적으로 **B+Tree 인덱스**를 사용하며,       
정렬된 상태로 저장되기 때문에 특정 값 혹은 범위를 빠르게 찾을 수 있다.

핵심 특징은 다음과 같다.

* 정렬된 구조를 유지한다.
* 빠른 탐색이 가능하다.
* 특정 컬럼 순서로 정렬된 구조이기 때문에 특정 조건에서 정렬이 필요 없다.
* 인덱스를 통해 테이블을 직접 읽지 않고도 원하는 데이터를 찾을 수 있다.
* 인덱스를 잘못 만들면 오히려 테이블 스캔보다 느릴 수 있다.

---

## 2. MySQL 인덱스의 동작 방식

### 2.1 B+Tree 구조

InnoDB 인덱스는 **B+Tree**를 기반으로 동작한다.

특징은 다음과 같다.

* 리프 노드는 항상 정렬된 순서로 연결되어 있다.
* 범위 스캔(range scan)이 매우 효율적이다.
* 인덱스는 선택도(selectivity)가 높을수록 효율적이다.
* 상위 노드에서 분기하며 특정 값을 빠르게 찾는다.

즉, B+Tree는 **빠른 검색 + 빠른 순차 읽기(범위 스캔)** 둘 다 가능한 자료구조이다.

---

## 3. 인덱스 스캔 방식

### 3.1 Index Range Scan

조건으로 인덱스 범위를 제한하여 연속된 구간을 스캔하는 방식이다.

예시:

```sql
SELECT *
FROM users
WHERE age BETWEEN 20 AND 30;
```

age 인덱스가 존재하면 다음이 가능하다.

1. age >= 20 위치로 바로 이동한다.
2. age <= 30 까지 연속해서 스캔한다.

이 경우 정렬 순서가 보장되므로 **정렬 없이 Single Pass**가 가능하다.

---

### 3.2 Index Full Scan

전체 인덱스를 처음부터 끝까지 읽는 방식이다.

예시:

```sql
SELECT COUNT(*) FROM users;
```

이 경우 모든 컬럼이 필요 없고 단지 개수만 필요하므로
테이블보다 작은 인덱스를 스캔하는 것이 더 효율적이다.

---

### 3.3 Index Skip Scan

인덱스 선두 컬럼 없이 후미 컬럼을 사용하여 스캔하는 방식이다.

예시:
인덱스: (country, age)

쿼리:

```sql
SELECT * FROM users WHERE age = 30;
```

이 경우 country가 없기 때문에 정상적인 range scan이 불가능하고
MySQL은 country별로 건너뛰어(age = 30을 찾기 위해) 인덱스를 훑어야 한다.
성능은 좋지 않다.

---

### 3.4 Index Lookup + Table Lookup

커버링 인덱스가 아닌 경우 인덱스로 PK만 찾고
실제 값을 얻기 위해 테이블을 한 번 더 읽어야 한다.

---

## 4. 왜 인덱스를 사용해도 범위 스캔이 불가능하면 Two Pass가 발생하는가

### 4.1 Single Pass / Range Scan이 가능한 조건

Single Pass를 위해서는 다음 조건을 충족해야 한다.

1. 인덱스가 정렬 순서를 제공해야 한다.
2. WHERE 조건 또는 ORDER BY가 인덱스 컬럼 순서와 일치해야 한다.
3. 인덱스에서 읽는 순서가 결과의 정렬 순서가 되어야 한다.

즉, 인덱스를 읽는 것만으로 **이미 정렬된 형태여야 한다.**

---

### 4.2 범위 스캔이 불가능하면 Two Pass가 필요한 이유

인덱스를 사용하더라도
**검색된 값의 순서가 ORDER BY나 GROUP BY 요구 조건을 충족하지 않으면**
반드시 한 번 더 정렬해야 한다.

예시:

```sql
SELECT *
FROM users
WHERE age BETWEEN 20 AND 30
ORDER BY id;
```

인덱스가 다음과 같다고 하자:

```
(age, name) 인덱스
```

문제:

* age 기준으로는 정렬되어 있지만
* id는 age, name 인덱스 순서와 아무 관련이 없다.

따라서 실행 순서는 다음과 같이 된다.

1. 인덱스 범위(age between 20 and 30)를 스캔한다.
2. 결과가 id 순으로 정렬되어 있지 않다.
3. 결과를 다시 id 기준으로 정렬한다.
4. Two Pass 발생한다.

결론:
인덱스를 쓰더라도 **정렬을 해결할 수 없으면 Two Pass가 필수**이다.

---

## 5. 인덱스를 어떻게 써야 하는가 (올바른 설계 가이드)

### 5.1 선두 컬럼 중요

복합 인덱스는 **왼쪽부터 사용해야 한다.**

인덱스: (a, b, c)

사용 가능:

* WHERE a = ?
* WHERE a = ? AND b = ?
* WHERE a = ? AND b = ? AND c BETWEEN ?

사용 불가능:

* WHERE b = ?
* WHERE c = ?

---

### 5.2 정렬 순서가 중요

ORDER BY가 인덱스 순서를 그대로 사용할 수 있도록 만든다.

예시: (user_id, created_at) 인덱스 사용 가능 쿼리

```sql
SELECT *
FROM logs
WHERE user_id = 10
ORDER BY created_at;
```

---

### 5.3 선택도 높은 컬럼을 앞에 둔다

선택도가 높다는 것은
**특정 값으로 필터링했을 때 많은 행이 제외되는 컬럼**을 의미한다.

예시:

* gender = 'M' (선택도 낮음)
* email = '[abc@example.com](mailto:abc@example.com)' (선택도 높음)

---

### 5.4 커버링 인덱스 사용하기

SELECT에 필요한 컬럼을 인덱스만으로 해결할 때 매우 빠르다.

예:
인덱스 (user_id, created_at, status)

```sql
SELECT user_id, created_at
FROM logs
WHERE user_id = 10;
```

커버링 인덱스이므로 테이블을 전혀 읽지 않는다.

---

### 5.5 잘못된 인덱스 설계 예시

#### 1) 선두 컬럼이 없는 WHERE 조건

인덱스: (a, b)

쿼리:

```sql
WHERE b = 10
```

이 경우 정렬된 구조를 사용할 수 없어 비효율적이다.

---

#### 2) 정렬 조건과 인덱스 불일치

인덱스: (age)

쿼리:

```sql
WHERE age BETWEEN 20 AND 40
ORDER BY created_at
```

Two Pass 발생한다.

---

#### 3) 불필요한 인덱스 난발

동일 컬럼에 여러 조합의 인덱스를 남발하면
인덱스 유지비용 증가로 성능에 악영향을 준다.

---

## 6. 인덱스 알고리즘 정리

### 6.1 B+Tree 인덱스

MySQL 기본 인덱스이다.

* 정렬 보장
* 범위 스캔 효율적
* 일반적인 조건 검색 최적

### 6.2 Hash 인덱스

Memory 엔진 전용이다.

* 동등 비교 매우 빠름
* 범위 검색 불가

### 6.3 Fulltext 인덱스

텍스트 검색 전용이다.

### 6.4 R-Tree 인덱스

GIS 데이터용이다.

---

## 7. 잘 쓰는 법 vs 잘못 쓰는 법 정리

### 잘 쓰는 법

* 복합 인덱스는 선두 컬럼 규칙을 따른다.
* 정렬과 인덱스 순서를 맞춘다.
* 범위 조건을 뒤에 배치한다.
* 커버링 인덱스를 적극 활용한다.
* 선택도 높은 컬럼을 앞에 둔다.
* UPDATE/DELETE가 많으면 인덱스를 최소화한다.

### 잘못 쓰는 법

* WHERE 조건과 무관한 인덱스를 만드는 경우
* 선두 컬럼을 고려하지 않은 복합 인덱스 생성
* ORDER BY, GROUP BY와 무관한 인덱스 생성
* 인덱스를 너무 많이 만드는 경우
* 낮은 선택도의 컬럼을 인덱스 앞에 두는 경우
* 인덱스로 정렬이 불가능한데도 정렬 성능을 기대하는 경우

---

## 8. 결론

1. 인덱스는 정렬된 B+Tree 구조로 범위 스캔과 순차 접근이 매우 빠르다.
2. 범위 스캔이 가능한 경우 Single Pass가 가능하나
3. 정렬 조건(ORDER BY, GROUP BY)이 인덱스 순서와 다르면 반드시 Two Pass가 발생한다.
4. 인덱스를 잘 설계하면 정렬과 검색 성능이 극적으로 향상된다.
5. 인덱스를 잘못 설계하면 오히려 테이블 스캔보다 느려진다.
