# 디자인 패턴 - 행위 패턴 비교

## 대표적인 행위 패턴 개요

| 패턴 이름 | 핵심 개념 | 주요 목적 | 적용 시기 |
|-----------|-----------|-----------|-----------|
| **스트래티지** | 알고리즘 군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만듦 | 실행 중에 알고리즘을 선택 가능하게 함 | 여러 알고리즘이 존재하고 런타임에 선택이 필요한 경우 |
| **옵저버** | 객체 간 일대다 의존성을 정의하여 한 객체의 상태가 변하면 모든 의존 객체에 자동 통지 | 객체 간의 느슨한 결합으로 상태 변화 전파 | 한 객체의 상태 변화를 여러 객체가 알아야 할 때 |
| **커맨드** | 요청을 객체로 캡슐화하여 매개변수화, 지연 실행, 취소 등이 가능하게 함 | 요청과 실행을 분리하여 유연성 확보 | 요청을 객체로 만들어 관리해야 할 때 |
| **템플릿 메서드** | 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현 | 알고리즘 구조는 유지하며 특정 단계 커스터마이즈 | 여러 클래스가 유사한 알고리즘을 공유하지만 일부 단계가 다른 경우 |
| **이터레이터** | 컬렉션의 요소들에 순차적으로 접근하는 방법을 표준화 | 컬렉션 구현과 순회 방식을 분리 | 다양한 컬렉션 구조에 일관된 접근 방법이 필요할 때 |
| **책임 연쇄** | 요청을 처리할 수 있는 객체들을 사슬처럼 연결하여 요청을 연쇄적으로 전달 | 요청 송신자와 수신자 간 결합도 감소 | 여러 객체 중 하나가 요청을 처리해야 하지만 처리자가 미정일 때 |

## 상세 특징 비교

| 패턴 이름 | 구성 요소 | 장점 | 단점 |
|-----------|-----------|------|------|
| **스트래티지** | Context, Strategy 인터페이스, ConcreteStrategy | 알고리즘 교체 용이, 조건문 제거 | 클래스 수 증가, 클라이언트가 적절한 전략 선택 필요 |
| **옵저버** | Subject, Observer 인터페이스, ConcreteObserver | Subject와 Observer 간 느슨한 결합, 브로드캐스트 통신 | 예상치 못한 업데이트, 메모리 누수 위험 |
| **커맨드** | Command 인터페이스, ConcreteCommand, Invoker, Receiver | 요청 큐, 로깅, 취소/재실행 기능 구현 용이 | 클래스 수 증가, 복잡도 상승 |
| **템플릿 메서드** | AbstractClass, ConcreteClass | 코드 재사용성 향상, Hollywood 원칙 적용 | 알고리즘 구조 변경 어려움, 제한된 확장성 |
| **이터레이터** | Iterator 인터페이스, ConcreteIterator, Aggregate | 컬렉션 순회 방식 단일화, SRP 준수 | 간단한 컬렉션에는 과도할 수 있음 |
| **책임 연쇄** | Handler 인터페이스, ConcreteHandler | 요청자와 처리자 분리, 처리 순서 유연성 | 요청 처리 보장 불가, 디버깅 어려움 |

## 비유적 설명

**스트래티지**: 운송 수단 선택 - 같은 목적지지만 자동차, 지하철, 자전거 등 다양한 방법으로 이동

**옵저버**: 신문 구독 시스템 - 신문사가 새로운 뉴스를 발행하면 모든 구독자에게 자동 배달

**커맨드**: 레스토랑 주문 - 손님의 주문을 주문서라는 객체로 만들어 요리사에게 전달

**템플릿 메서드**: 건축 청사진 - 기본 구조는 동일하지만 내부 마감재는 각 주택별로 다르게 구현

**이터레이터**: 박물관 안내 도슨트 - 다양한 전시관을 일관된 방식으로 순차적으로 관람 안내

**책임 연쇄**: 기업 의사결정 프로세스 - 사원 → 과장 → 부장 → 사장으로 이어지는 결재 라인
